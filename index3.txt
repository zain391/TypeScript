// now we are going to study objects in details
const myself={
    name:'zain',
    age:30,
}
function greet(person:{name:string, age:number}){
    console.log(typeof person);
    
}
greet(myself);
// the methode above is not efficent as it make the code more complex as is if we want to add more properties in the object  the code in the one line we will be increasing gradually 
// so we  made interfaces for the objects in the typescript 
interface objects{
    name :string,
    age:number,
}
// now as we have created the interface for the object we can use it 
function greet2(person1:objects){
    return person1.name;
}
let myself2:objects={
    name:'zain2',
    age:20,
}
greet2(myself2);
// in some of our cases we do not want to use all the properties of the objects so in that particular case we add the Question mark at the end of the property 
interface Qusetionmark{
    east:string,
    nortwest?:string,
    west?:string,
    northEast?:string,
}
const pak1:Qusetionmark={
    east:'India'
}
// as we can see know the typescript is not giving us error and still we are not using all the properties of the object 

// const pak2:Qusetionmark={
//         nortwest:'Afghanistan'
// }

// now we can see that we did not add the ? with tht east so the typescript is gu=iving us the error that we have to use it 
const pak3:Qusetionmark={
    east:'India',
    nortwest:"Afghanistan",
    west:'Iran',
    northEast:'northEast',
}
console.log(pak1);
// console.log(pak2);
console.log(pak3);
// const mes:string='Message';
// async function test(){
//     // the async function return a promise 
//     console.log(`${2} : ${mes}`);
//      await console.log(`${3} : ${mes}`);
//      console.log(`${4} : ${mes}`);
//     return "i am resolved "     
// }
// console.log(`${1} : ${mes}`);
// test();
// console.log(`${5} : ${mes}`);
// console.log(test());
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function test2() {
    return __awaiter(this, void 0, void 0, function () {
        var response, students;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    // the async function return a promise 
                    console.log("".concat(2, " : ").concat(mes));
                    response = fetch("std.record.JSON");
                    return [4 /*yield*/, response];
                case 1:
                    students = (_a.sent()).json();
                    return [4 /*yield*/, console.log("".concat(3, " : ").concat(mes))];
                case 2:
                    _a.sent();
                    console.log("".concat(4, " : ").concat(mes));
                    return [2 /*return*/, students];
            }
        });
    });
}
console.log("".concat(1, " : ").concat(mes));
test().then(function () {
    console.log('i am resolved ');
})["catch"](function (error) {
    console.log(error);
});
console.log("".concat(5, " : ").concat(mes));
console.log(test2());
